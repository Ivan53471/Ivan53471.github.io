<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title>Hello World</title>
    <url>/2024/03/23/hello-world/</url>
    <content><![CDATA[<p>Welcome to <a href="https://hexo.io/">Hexo</a>! This is your very first post. Check <a href="https://hexo.io/docs/">documentation</a> for more info. If you get any problems when using Hexo, you can find the answer in <a href="https://hexo.io/docs/troubleshooting.html">troubleshooting</a> or you can ask me on <a href="https://github.com/hexojs/hexo/issues">GitHub</a>.</p>
<h2><span id="quick-start">Quick Start</span></h2><h3><span id="create-a-new-post">Create a new post</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo new <span class="string">&quot;My New Post&quot;</span></span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/writing.html">Writing</a></p>
<h3><span id="run-server">Run server</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo server</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/server.html">Server</a></p>
<h3><span id="generate-static-files">Generate static files</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo generate</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/generating.html">Generating</a></p>
<h3><span id="deploy-to-remote-sites">Deploy to remote sites</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">$ hexo deploy</span><br></pre></td></tr></table></figure>

<p>More info: <a href="https://hexo.io/docs/one-command-deployment.html">Deployment</a></p>
]]></content>
      <categories>
        <category>startup</category>
      </categories>
  </entry>
  <entry>
    <title>My First Post</title>
    <url>/2024/03/23/My-First-Post/</url>
    <content><![CDATA[<h2><span id="start-my-blogging-journey">Start My Blogging Journey</span></h2><p>This is my first post. Although it seems to be essential, I have never done this before.<br>I want to create my own blog, which can show my identity.</p>
<h2><span id="another-reason">Another Reason</span></h2><p>I am publishing this blog post as part of my assignment for the cloud computing course.<br>My name is 黄梓铭 and my ID number is 21311151.</p>
]]></content>
      <categories>
        <category>startup</category>
      </categories>
  </entry>
  <entry>
    <title>Go调用geth JSON RPC接口</title>
    <url>/2024/03/27/Go%E8%B0%83%E7%94%A8geth_JSON_RPC%E6%8E%A5%E5%8F%A3/</url>
    <content><![CDATA[<p>在Go中调用以太坊的格式如下</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line">client, _ := rpc.Dial(<span class="string">&quot;http://localhost:8545&quot;</span>)</span><br><span class="line"><span class="keyword">var</span> result <span class="type">bool</span></span><br><span class="line">client.Call(&amp;result ,<span class="string">&quot;net_listening&quot;</span>) </span><br></pre></td></tr></table></figure>

<p>有以下常用接口</p>
<h2><span id="net">net</span></h2><p>1、net_version<br>当前连接网络的ID</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> networkid <span class="type">string</span></span><br><span class="line">client.Call(&amp;networkid,<span class="string">&quot;net_version&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>2、net_listening<br>客户端是否处于监听状态</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> is_listing <span class="type">bool</span></span><br><span class="line">client.Call(&amp;is_listing,<span class="string">&quot;net_listening&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2><span id="eth">eth</span></h2><p>1、eth_accounts<br>返回账户地址数组</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> accounts []<span class="type">string</span></span><br><span class="line">client.Call(&amp;accounts,<span class="string">&quot;eth_accounts&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>2、eth_getBalance<br>需要传入账户地址，返回余额，单位是<em>wei</em><br> “latest” 表示你要查询的是当前链上最新的账户余额</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> balance <span class="type">string</span></span><br><span class="line">client.Call(&amp;balance,<span class="string">&quot;eth_getBalance&quot;</span>,<span class="string">&quot;0x558c90c05d8c4b55a87de03bd601fd76faf50f9b&quot;</span>,<span class="string">&quot;latest&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>3、eth_coinbase<br>获取挖矿账户地址</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> proto_version <span class="type">string</span></span><br><span class="line">client.Call(&amp;proto_version , <span class="string">&quot;eth_protocolVersion&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>4、eth_mining<br>返回客户端是否在挖矿</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> is_mining <span class="type">bool</span></span><br><span class="line">client.Call(&amp;is_mining,<span class="string">&quot;eth_mining&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>5、eth_getTransactionCount<br>返回指定地址发生的交易数量</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> transactionCount <span class="type">string</span></span><br><span class="line">client.Call(&amp;transactionCount,<span class="string">&quot;eth_getBalance&quot;</span>,<span class="string">&quot;0x72w12d05d8c4b55a87de03bd601fd76faf50f9b&quot;</span>,<span class="string">&quot;latest&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>6、eth_blockNumber<br>获取当前块编号</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> blockNum <span class="type">string</span></span><br><span class="line">client.Call(&amp;blockNum ,<span class="string">&quot;eth_blockNumber&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2><span id="personal">personal</span></h2><p>1、personal_listAccounts<br>获取该节点下的所有账户</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> accounts []<span class="type">string</span></span><br><span class="line">client.Call(&amp;accounts,<span class="string">&quot;personal_listAccounts&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>2.personal_newAccount<br>创建用户，需要将密码作为参数传入</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> newAccount <span class="type">string</span></span><br><span class="line">client.Call(&amp;newAccount, <span class="string">&quot;personal_newAccount&quot;</span>, <span class="string">&quot;12345678&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>3.personal_lockAccount<br>锁定指定账户，需要将地址作为参数传入</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> is_lock <span class="type">bool</span></span><br><span class="line">client.Call(&amp;is_lock, <span class="string">&quot;personal_lockAccount&quot;</span>, <span class="string">&quot;账户地址&quot;</span>)</span><br></pre></td></tr></table></figure>

<p>4.personal_unlockAccount<br>解锁指定账户,有些操作必须解锁账户才可以操作</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> is_unlock <span class="type">bool</span></span><br><span class="line">client.Call(&amp;is_unlock, <span class="string">&quot;personal_lockAccount&quot;</span>, <span class="string">&quot;账户地址&quot;</span>,<span class="string">&quot;账户密码&quot;</span>)</span><br></pre></td></tr></table></figure>

<h2><span id="db">db</span></h2><p>1.db_putString<br>在本地数据库中存入字符串</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> is_ok <span class="type">bool</span></span><br><span class="line">client.Call(&amp;is_ok, <span class="string">&quot;db_putString&quot;</span>, <span class="string">&quot;db_name&quot;</span>,<span class="string">&quot;key&quot;</span>,<span class="string">&quot;&quot;</span>value<span class="string">&quot;)</span></span><br></pre></td></tr></table></figure>

<p>2.db_getString<br>从本地数据库读取字符串</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">var</span> val <span class="type">string</span></span><br><span class="line">client.Call(&amp;val, <span class="string">&quot;db_getString&quot;</span>, <span class="string">&quot;db_name&quot;</span>,<span class="string">&quot;key&quot;</span>)</span><br></pre></td></tr></table></figure>]]></content>
      <categories>
        <category>科研</category>
      </categories>
  </entry>
  <entry>
    <title>Linux系统构建以太坊私链</title>
    <url>/2024/03/26/%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E9%93%BE/</url>
    <content><![CDATA[<h2><span id="配置go环境">配置Go环境</span></h2><p>1、首先切换到管理员身份</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo -s</span><br></pre></td></tr></table></figure>

<p>2、下载官⽅的 go 语⾔编译器压缩包</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">wget https://go.dev/dl/go1.21.3.linux-amd64.tar.gz</span><br></pre></td></tr></table></figure>

<p>3、解压缩刚下载的新版本并放置到合适的位置</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">tar -C /usr/local -xzf go1.21.3.linux-amd64.tar.gz</span><br><span class="line">（如果有旧版本，先输入 `rm -rf /usr/local/go` 移除）</span><br></pre></td></tr></table></figure>

<p>4、设定环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:/usr/local/go/bin</span><br></pre></td></tr></table></figure>
<p>试试看是否正常（应该会看到版本号）</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">go version</span><br></pre></td></tr></table></figure>

<h2><span id="构建geth">构建geth</span></h2><p>1、下载git</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">sudo apt install git</span><br></pre></td></tr></table></figure>

<p>2、克隆以太坊源码<br>这一步很可能连不上github，没什么解决方法，多试</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">git clone https://github.com/ethereum/go-ethereum.git</span><br></pre></td></tr></table></figure>

<p>3、进入ethereum所在文件夹</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd go-ethereum</span><br></pre></td></tr></table></figure>

<hr>
<p>24-04-09: 现在直接克隆以太坊仓库下载的 geth 版本是 1.14.0-unstable，所以在运行链的时候就会出现以下报错，应该要先切换到 1.13版本</p>
<img data-src="/2024/03/26/%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E9%93%BE/use_fatal.png" class>

<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd go-ethereum</span><br><span class="line">git checkout release/1.13</span><br><span class="line">git pull</span><br></pre></td></tr></table></figure>

<p>4、编译geth</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">make geth</span><br></pre></td></tr></table></figure>
<p>如果发现下载很慢，可以终止掉，设置代理</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export GOPROXY=https://goproxy.io,direct</span><br></pre></td></tr></table></figure>
<p>下载完成，应该可以看到以下画面</p>
<img data-src="/2024/03/26/%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E9%93%BE/%E4%B8%8B%E8%BD%BD%E5%AE%8C%E6%88%90.png" class>

<p>5、进⼊⽬录</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">cd build/bin</span><br></pre></td></tr></table></figure>

<p>6、启动主程序，连接主⽹并同步</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">./geth</span><br></pre></td></tr></table></figure>

<p>7、配置环境变量</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">nano ~/.bashrc</span><br></pre></td></tr></table></figure>
<p>在该文件最后添加以下语句，要注意替换成自己主机的geth所在路径 (前面的~也要修改)</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">export PATH=$PATH:~/Desktop/go-ethereum/build/bin</span><br></pre></td></tr></table></figure>
<p>退出后输入以下语句让更改生效，并检测是否配置成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source ~/.bashrc</span><br><span class="line">geth version</span><br></pre></td></tr></table></figure>

<h2><span id="搭建私链">搭建私链</span></h2><p>1、创造配置文件<br>在不同于以太坊源码的文件路径下创一个文件夹和.json文件，命名为genesis.json，可以在桌面创建</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// 注意要记得切换到管理员模式，才能创建文件夹</span><br><span class="line">sudo -s</span><br><span class="line">mkdir ./project</span><br><span class="line">mkdir ./project/MyChain</span><br><span class="line">vim ./project/MyChain/genesis.json</span><br><span class="line">// 修改完输入:wq退出vim</span><br></pre></td></tr></table></figure>
<p>在这个 json 文件下，配置这个私链的参数<br>这里使用的共识机制是 <a href="https://geth.ethereum.org/docs/tools/clef/clique-signing">Clique</a>，</p>
<figure class="highlight json"><table><tr><td class="code"><pre><span class="line"><span class="punctuation">&#123;</span></span><br><span class="line">  <span class="attr">&quot;config&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;chainId&quot;</span><span class="punctuation">:</span> <span class="number">12345</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;homesteadBlock&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eip150Block&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eip155Block&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;eip158Block&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;byzantiumBlock&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;constantinopleBlock&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;petersburgBlock&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;istanbulBlock&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;berlinBlock&quot;</span><span class="punctuation">:</span> <span class="number">0</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;clique&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">      <span class="attr">&quot;period&quot;</span><span class="punctuation">:</span> <span class="number">5</span><span class="punctuation">,</span></span><br><span class="line">      <span class="attr">&quot;epoch&quot;</span><span class="punctuation">:</span> <span class="number">30000</span></span><br><span class="line">    <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;difficulty&quot;</span><span class="punctuation">:</span> <span class="string">&quot;1&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;gasLimit&quot;</span><span class="punctuation">:</span> <span class="string">&quot;8000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;extradata&quot;</span><span class="punctuation">:</span> <span class="string">&quot;0x0000000000000000000000000000000000000000000000000000000000000000890fb1799fe7fa4b8e01ccf343e088d946fcd5560000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000000&quot;</span><span class="punctuation">,</span></span><br><span class="line">  <span class="attr">&quot;alloc&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span></span><br><span class="line">    <span class="attr">&quot;890fb1799fe7fa4b8e01ccf343e088d946fcd556&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;balance&quot;</span><span class="punctuation">:</span> <span class="string">&quot;300000&quot;</span> <span class="punctuation">&#125;</span><span class="punctuation">,</span></span><br><span class="line">    <span class="attr">&quot;14c6ead33b265da463eef7367798ade6aa8e9d12&quot;</span><span class="punctuation">:</span> <span class="punctuation">&#123;</span> <span class="attr">&quot;balance&quot;</span><span class="punctuation">:</span> <span class="string">&quot;400000&quot;</span> <span class="punctuation">&#125;</span></span><br><span class="line">  <span class="punctuation">&#125;</span></span><br><span class="line"> <span class="punctuation">&#125;</span></span><br><span class="line"></span><br></pre></td></tr></table></figure>

<p>2、初始化链</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">geth --datadir ./project/MyChain/ init ./project/MyChain/genesis.json</span><br></pre></td></tr></table></figure>
<p>成功后会出现以下提示 (可能会有 Error 信息，可以忽略)</p>
<img data-src="/2024/03/26/%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E9%93%BE/init.png" class>

<p>假如出现以下报错，可以删除 .&#x2F;project&#x2F;MyChain&#x2F; 目录下新生成的两个文件夹，只保留 .json 文件</p>
<img data-src="/2024/03/26/%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E9%93%BE/init_fatal.png" class>


<p>3、启用链<br>此处启用私链，并且开启RPC接口</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">geth --datadir ./project/MyChain/ --identity &quot;MyETH&quot; --rpc --rpcport 8545  --rpcapi &quot;db,eth,net,web3,personal&quot; --rpccorsdomain &quot;*&quot; --networkid 15 console</span><br></pre></td></tr></table></figure>

<ul>
<li>identity “MyETH”：节点身份标识</li>
<li>rpc：开启 RPC 接口</li>
<li>rpcport：指定端口</li>
<li>rpcapi：开启的RPC API</li>
<li>rpccorsdomain：跨域请求，”*”为允许所有来源的跨域请求</li>
<li>networkid：网络标识符，用于连上私链，networkid是在genesis.json中确定的<br>console：打开geth控制台，用于创建节点和部署智能合约</li>
</ul>
<hr>
<p>24-04-09: 在实验的时候发现，在较新版本的 geth 中，rpc 相关的指令已经不用 –rpcxxx，改为 –http.xxx</p>
<ul>
<li>http：开启 RPC 接口</li>
<li>http.port：指定端口</li>
<li>http.api：开启的RPC API</li>
<li>http.corsdomain：跨域请求，”*”为允许所有来源的跨域请求<br>而且，db 接口也已经被弃用，<br>所以，该命令将变为</li>
</ul>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">geth --datadir ./project/MyChain/ --identity &quot;MyETH&quot; --http --http.port 8545  --http.api &quot;eth,net,web3,personal&quot; --http.corsdomain &quot;*&quot; --networkid 12345 console</span><br></pre></td></tr></table></figure>
<p>成功后将出现以下页面</p>
<img data-src="/2024/03/26/%E6%90%AD%E5%BB%BA%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E9%93%BE/success.png" class>


<h2><span id="创建用户并挖矿">创建用户并挖矿</span></h2><p>1、在控制台中创建用户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">personal.newAccount(&quot;123456&quot;)//括号内是自定义的密码，返回“0x......”为创建出来的用户的地址。之后要用到。</span><br><span class="line">eth.accounts //查询用户</span><br><span class="line">eth.getBalance(eth.accounts[0]) // 通过eth.accounts[0]查询账户余额。若私链上有多个用户，第一个用户为eth.accounts[0]，第二个为eth.accounts[1]。以此类推。</span><br><span class="line">eth.getBalance(&quot;0x......账户地址&quot;) // 通过地址查询出账户余额</span><br></pre></td></tr></table></figure>

<hr>
<p>24-04-09: 实验中发现 personal 已经被弃用，geth 控制台似乎也没有其他方法新创建账户。官方给出的解决方案是使用和 geth 解耦的 <a href="https://geth.ethereum.org/docs/tools/clef/introduction">clef</a> 创建账号<br>个人认为，通过另开一个终端，使用以下命令创建账户会更方便</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">geth account new --datadir ./project/MyChain/</span><br></pre></td></tr></table></figure>

<p>2、开始挖矿</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eth.coinbase // 第一种查看矿工的账户地址的方式，该地址默认为第一个账户地址</span><br><span class="line">web3.eth.coinbase // 第二种查看方式矿工地址的方式</span><br><span class="line">miner.setEtherbase(eth.accounts[1]) </span><br><span class="line">//设置矿工用户。矿工的账户地址即奖励地址，括号里面填写用户地址。这里设置eth.accounts[1]为挖矿的账户地址。</span><br></pre></td></tr></table></figure>

<p>3、停止挖矿<br>挖一段时间后，账户就有钱了，可以部署智能合约（部署智能合约需要花钱），可以停止挖矿</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">miner.stop()</span><br><span class="line">//输入此命令停止挖矿。你在输入此命令时可能会发现。你边输入电脑一边还在挖矿。但是不用担心它回打断你的输入。你只要一股脑的输入miner.stop()回车就完事了。打断了不要重新输，要继续输入。回车就停下来了。</span><br><span class="line">eth.getBalance(eth.accounts[0])</span><br><span class="line">//再查账户，发现自己突然有钱了。</span><br></pre></td></tr></table></figure>

<h2><span id="部署智能合约">部署智能合约</span></h2><p>参照下一篇文章</p>
<a href="/2024/03/30/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E9%93%BE%E9%83%A8%E7%BD%B2%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/" title="以太坊私链部署智能合约">以太坊私链部署智能合约</a>

<!-- 在admin里面可以看到监听的端口号

personal.newAccount() 创建新用户
输入密码，返回值是账户地址

personal.unlockAccount(eth.accounts[0]) 
之后就可以输入密码，解锁账号

miner.start 开始挖矿

geth --datadir ../project/MyChain/ --networkid 15 console 2>output.log
2代表输出，>是重定向

geth --datadir ../project/MyChain/ --networkid 15 --rpc console 2>output.log

可以用开发者模式 -dev -->

]]></content>
      <categories>
        <category>科研</category>
      </categories>
  </entry>
  <entry>
    <title>综合实训调研</title>
    <url>/2024/03/28/%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD%E8%B0%83%E7%A0%94/</url>
    <content><![CDATA[<p>由于综合实践项目需要用到Flink CDC、Kafka、ElasticSearch、Kibana、Doris，以下是对这些框架&#x2F;技术的调研</p>
<h2><span id="flink-cdc">Flink CDC</span></h2><p><a href="https://nightlies.apache.org/flink/flink-cdc-docs-release-3.0/zh/docs/get-started/introduction/">Flink CDC</a> 是一个基于流的数据集成工具，旨在为用户提供一套功能更加全面的编程接口（API）。</p>
<h3><span id="事件">事件</span></h3><p>事件分为DataChangeEvent、SchemaChangeEvent、Flow of Events</p>
<h4><span id="datachangeevent">DataChangeEvent</span></h4><p><em>DataChangeEvent</em> 描述了源中的数据变更。它由 5 个字段组成：</p>
<ul>
<li>Table ID：事件所属的表 ID</li>
<li>Before：数据的前置图像</li>
<li>After：数据的后置图像</li>
<li>Operation type：变更操作的类型</li>
<li>Meta：变更的元数据</li>
</ul>
<p>操作类型字段预定义了 4 种操作类型：</p>
<ul>
<li>插入（Insert）：新数据条目，before &#x3D; null，after &#x3D; 新数据</li>
<li>删除（Delete）：数据删除，before &#x3D; 被删除的数据，after &#x3D; null</li>
<li>更新（Update）：已存在数据的更新，before &#x3D; 变更前的数据，after &#x3D; 变更后的数据</li>
<li>替换（Replace）</li>
</ul>
<h4><span id="schemachangeevent">SchemaChangeEvent</span></h4><p><em>SchemaChangeEvent</em> 描述了外部系统中表结构的更改</p>
<ul>
<li>AddColumnEvent：表中的新列</li>
<li>AlterColumnTypeEvent：列类型的更改</li>
<li>CreateTableEvent：创建新表。也用于描述预发出的 DataChangeEvent 的模式</li>
<li>DropColumnEvent：删除列</li>
<li>RenameColumnEvent：列名更改</li>
</ul>
<h4><span id="事件流">事件流</span></h4><p>如果一个表对框架是新的，则在任何 DataChangeEvent 之前必须发出 CreateTableEvent；如果表的 schema 发生变化，则必须在任何 DataChangeEvent 之前发出 SchemaChangeEvent。</p>
<img data-src="/2024/03/28/%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD%E8%B0%83%E7%A0%94/flow-of-events.png" class title="事件流图">

<h3><span id="如何使用-flink-cdc">如何使用 Flink CDC</span></h3><p><a href="https://nightlies.apache.org/flink/flink-cdc-docs-release-3.0/zh/docs/get-started/quickstart/mysql-to-doris/">MySQL 同步到 Doris</a><br>Flink CDC 提供了基于 YAML 格式的用户 API，更适合于数据集成场景。以下是一个 YAML 文件的示例，它定义了一个数据管道(Pipeline)，该Pipeline从 MySQL 捕获实时变更，并将它们同步到 Apache Doris：</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">source:</span><br><span class="line">  type: mysql</span><br><span class="line">  hostname: localhost</span><br><span class="line">  port: 3306</span><br><span class="line">  username: root</span><br><span class="line">  password: 123456</span><br><span class="line">  tables: app_db.\.*</span><br><span class="line">  server-id: 5400-5404</span><br><span class="line">  server-time-zone: UTC</span><br><span class="line"></span><br><span class="line">sink:</span><br><span class="line">  type: doris</span><br><span class="line">  fenodes: 127.0.0.1:8030</span><br><span class="line">  username: root</span><br><span class="line">  password: &quot;&quot;</span><br><span class="line">  table.create.properties.light_schema_change: true</span><br><span class="line">  table.create.properties.replication_num: 1</span><br><span class="line"></span><br><span class="line">pipeline:</span><br><span class="line">  name: Sync MySQL Database to Doris</span><br><span class="line">  parallelism: 2</span><br></pre></td></tr></table></figure>
<p>源数据库（source）是 MySQL，连接信息包括主机名（localhost）、端口（3306）、用户名（root）、密码（123456）、表（app_db下的所有表）、服务器ID（5400-5404）和服务器时区（UTC）。<br>目标数据库（sink）是 Doris，连接信息包括FE节点（127.0.0.1:8030）、用户名（root）、密码（空字符串，即没有密码）、表创建属性（包括轻量模式变更和复制数等设置）。<br>Pipeline 部分定义了数据同步任务的名称（Sync MySQL Database to Doris）和并行度（2）。</p>
<h2><span id="kafka">Kafka</span></h2><p>Kafka 是由 Linkedin 公司开发的，它是一个分布式的，支持多分区、多副本，基于 Zookeeper 的分布式消息流平台，它同时也是一款开源的基于发布订阅模式的消息引擎系统。</p>
<h3><span id="主要术语">主要术语</span></h3><p>以下文段摘录于 <a href="https://kafka.apache.org/intro">kafka</a> 官方。</p>
<p>An <em>event</em> records the fact that “something happened” in the world or in your business. It is also called record or message in the documentation. When you read or write data to Kafka, you do this in the form of events. Conceptually, an event has a <em>key</em>, <em>value</em>, <em>timestamp</em>, and <em>optional metadata headers</em>.<br>An example：</p>
<ul>
<li>key：“Alice”</li>
<li>value：“向 Bob 支付了 200 美元”</li>
<li>timestamp：“2020 年 6 月 25 日下午 2：06”。</li>
</ul>
<p><em>Producers</em> are those client applications that publish (write) events to Kafka, and <em>consumers</em> are those that subscribe to (read and process) these events. </p>
<img data-src="/2024/03/28/%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD%E8%B0%83%E7%A0%94/%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85.png" class title="生产者-消费者模式">

<p>Events are organized and durably stored in <em>topics</em>. A topic is similar to a folder in a filesystem, and the events are the files in that folder. Topics in Kafka are always <strong>multi-producer and multi-subscriber</strong>.</p>
<p>Topics are partitioned, meaning a topic is spread over a number of “buckets” located on different Kafka brokers. </p>
<p>Kafka 保证具有相同 Key 的事件写入被同一分区，读取时按写入顺序读。但是 Kafka <strong>不保证</strong>不同 Partition 获取的信息是有序的，只保证同 Partition 内消息有序。</p>
<img data-src="/2024/03/28/%E7%BB%BC%E5%90%88%E5%AE%9E%E8%AE%AD%E8%B0%83%E7%A0%94/Kafka.png" class title="分区示意图">

<h3><span id="快速入门-kafka">快速入门 Kafka</span></h3><p><a href="https://kafka.apache.org/quickstart">快速入门</a></p>
<h3><span id="kafka-和-rabbitmq-的区别">Kafka 和 RabbitMQ 的区别</span></h3><table>
<thead>
<tr>
<th>特性</th>
<th>RabbitMQ</th>
<th>Kafka</th>
</tr>
</thead>
<tbody><tr>
<td>架构</td>
<td>RabbitMQ 的架构专为复杂的消息路由而设计。该代理使用推送模型。生产者使用不同的规则向使用者发送消息。</td>
<td>Kafka 使用基于分区的设计进行实时、高吞吐量的流处理。该代理使用拉取模型。生产者向使用者订阅的主题和分区发布消息。</td>
</tr>
<tr>
<td>消息处理</td>
<td>RabbitMQ 代理监控消息使用。此代理会在消息被使用后将其删除。它支持消息优先级。</td>
<td>使用者使用偏移跟踪器跟踪消息检索情况。Kafka 根据保留策略保留消息。其中没有消息优先级。</td>
</tr>
<tr>
<td>性能</td>
<td>RabbitMQ 提供低延迟。它每秒发送数千条消息。</td>
<td>Kafka 每秒可实时传输多达数百万条消息。</td>
</tr>
<tr>
<td>编程语言</td>
<td>RabbitMQ 支持多种语言和旧式协议。</td>
<td>Kafka 的编程语言选择有限。该代理在 TCP 上使用二进制协议进行数据传输。</td>
</tr>
</tbody></table>
<h2><span id="elasticsearch">ElasticSearch</span></h2><p><a href="https://www.elastic.co/guide/en/elasticsearch/reference/current/documents-indices.html">Elasticsearch</a> is a distributed document store. Instead of storing information as rows of columnar data, Elasticsearch stores complex data structures that have been serialized as JSON documents.</p>
<p>Elasticsearch REST API 支持结构化查询、全文查询和将两者结合在一起的查询的复杂查询 </p>
<p>和普通的数据库模糊搜索不同，<em>Elasticsearch</em> 的模糊搜索是能使用上索引的，所以在大数据场景下搜索速度快；而且，<em>Elasticsearch</em> 的模糊搜索支持排序，只返回排名高的记录；另外，<em>Elasticsearch</em> 的模糊搜索在遇到不太准确的关键字时也能搜出相关结果。</p>
<h2><span id="kibana">Kibana</span></h2><p><a href="https://www.elastic.co/guide/en/kibana/current/introduction.html">Kibana</a> enables you to give shape to your data and navigate the Elastic Stack</p>
<h3><span id="kibana-和-elasticsearch-关系">Kibana 和 ElasticSearch 关系</span></h3><p>Kibana 运行在 Elasticsearch 之上，主要用于分析日志消息。</p>
]]></content>
      <categories>
        <category>学习</category>
        <category>综合实训</category>
      </categories>
  </entry>
  <entry>
    <title>以太坊私链部署智能合约</title>
    <url>/2024/03/30/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E9%93%BE%E9%83%A8%E7%BD%B2%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/</url>
    <content><![CDATA[<h2><span id="编写智能合约">编写智能合约</span></h2><p>以下编写了一个简单的存储智能合约，不是 <em>NFT</em> 智能合约。</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">// SPDX-License-Identifier: GPL-3.0</span><br><span class="line">pragma solidity &gt;=0.4.16 &lt;0.9.0;</span><br><span class="line"></span><br><span class="line">contract SimpleStorage &#123;</span><br><span class="line">    uint storedData;</span><br><span class="line"></span><br><span class="line">    function set(uint x) public &#123;</span><br><span class="line">        storedData = x;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function get() public view returns (uint) &#123;</span><br><span class="line">        return storedData;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    function add(uint x) public &#123;</span><br><span class="line">        uint y = x + storedData;</span><br><span class="line">        storedData = y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>

<h2><span id="编译智能合约">编译智能合约</span></h2><p>在 <em>Remix</em> 上compile刚刚写好的智能合约，然后会出现以下界面，ABI 和 Bytecode 待会需要用到  </p>
<img data-src="/2024/03/30/%E4%BB%A5%E5%A4%AA%E5%9D%8A%E7%A7%81%E9%93%BE%E9%83%A8%E7%BD%B2%E6%99%BA%E8%83%BD%E5%90%88%E7%BA%A6/image.png" class>

<h2><span id="部署智能合约">部署智能合约</span></h2><p>这里实现两种部署智能合约的方式，一种是在 geth 控制台部署，一种是使用 Go 实现</p>
<h3><span id="geth-控制台部署">geth 控制台部署</span></h3><p>1、解锁账户</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">personal.unlockAccount(eth.coinbase)</span><br></pre></td></tr></table></figure>

<p>2、录入智能合约的 bytecode</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var code = </span><br><span class="line">&quot;6080604052348015600e575f80fd5b506101e48061001c5f395ff3fe608060405234801561000f575f80fd5b506004361061003f575f3560e01c80631003e2d21461004357806360fe47b11461005f5780636d4ce63c1461007b575b5f80fd5b61005d600480360381019061005891906100fb565b610099565b005b610079600480360381019061007491906100fb565b6100b3565b005b6100836100bc565b6040516100909190610135565b60405180910390f35b5f8054826100a7919061017b565b9050805f819055505050565b805f8190555050565b5f8054905090565b5f80fd5b5f819050919050565b6100da816100c8565b81146100e4575f80fd5b50565b5f813590506100f5816100d1565b92915050565b5f602082840312156101105761010f6100c4565b5b5f61011d848285016100e7565b91505092915050565b61012f816100c8565b82525050565b5f6020820190506101485f830184610126565b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f610185826100c8565b9150610190836100c8565b92508282019050808211156101a8576101a761014e565b5b9291505056fea26469706673582212209645cec1c57b3e0ea64b23d942988cdc634242f2c015ac31b32aa6ddac78ade164736f6c63430008190033&quot;</span><br></pre></td></tr></table></figure>

<p>3、录入智能合约的 ABI<br>ABI 需要先经过压缩转义</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">var abi=JSON.parse(&#x27;[&#123;\&quot;inputs\&quot;:[&#123;\&quot;internalType\&quot;:\&quot;uint256\&quot;,\&quot;name\&quot;:\&quot;x\&quot;,\&quot;type\&quot;:\&quot;uint256\&quot;&#125;],\&quot;name\&quot;:\&quot;add\&quot;,\&quot;outputs\&quot;:[],\&quot;stateMutability\&quot;:\&quot;nonpayable\&quot;,\&quot;type\&quot;:\&quot;function\&quot;&#125;,&#123;\&quot;inputs\&quot;:[],\&quot;name\&quot;:\&quot;get\&quot;,\&quot;outputs\&quot;:[&#123;\&quot;internalType\&quot;:\&quot;uint256\&quot;,\&quot;name\&quot;:\&quot;\&quot;,\&quot;type\&quot;:\&quot;uint256\&quot;&#125;],\&quot;stateMutability\&quot;:\&quot;view\&quot;,\&quot;type\&quot;:\&quot;function\&quot;&#125;,&#123;\&quot;inputs\&quot;:[&#123;\&quot;internalType\&quot;:\&quot;uint256\&quot;,\&quot;name\&quot;:\&quot;x\&quot;,\&quot;type\&quot;:\&quot;uint256\&quot;&#125;],\&quot;name\&quot;:\&quot;set\&quot;,\&quot;outputs\&quot;:[],\&quot;stateMutability\&quot;:\&quot;nonpayable\&quot;,\&quot;type\&quot;:\&quot;function\&quot;&#125;]&#x27;)</span><br></pre></td></tr></table></figure>

<p>4、部署智能合约</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">eth.estimateGas(&#123;data: code&#125;) //先估算需要多大的gas</span><br><span class="line"></span><br><span class="line">//创建智能合约类</span><br><span class="line">var myContract = eth.contract(abi)</span><br><span class="line">//创建合约实例</span><br><span class="line">//from后填写的是账户的地址，gas后填写你愿意支付的gas</span><br><span class="line">var contract1 = myContract.new(&#123;from:&quot;account_address&quot;, data:code, gas:2000000&#125;)</span><br></pre></td></tr></table></figure>

<p>5、启动节点挖矿<br>因为在私链上没有其他节点挖矿，而部署智能合约也是一笔交易，所以需要节点挖矿使这笔交易打包上链，智能合约才部署成功</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">miner.start()</span><br><span class="line">miner.stop()</span><br><span class="line">contract1.address //查看部署到链上的合约的地址</span><br></pre></td></tr></table></figure>

<p>6、调用智能合约<br>第一种调用用于需要花费 gas 的函数，第二种则用于不需要花费 gas 的函数</p>
<figure class="highlight plaintext"><table><tr><td class="code"><pre><span class="line">personal.unlockAccount(eth.coinbase)</span><br><span class="line">contract.function_name.sendTransaction(&quot;parameter_1&quot;,&quot;parameter_2&quot;,&#123;from:&quot;account_address&quot;&#125;)</span><br><span class="line">contract.function_name.call(&quot;parameter_1&quot;,&quot;parameter_2&quot;)</span><br></pre></td></tr></table></figure>

<h3><span id="使用-go-部署">使用 Go 部署</span></h3><p>这里想要实现的效果是，每次新创建一个账户的时候，都会自动部署该智能合约，这一功能用 Go 实现。</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="keyword">package</span> main</span><br><span class="line"></span><br><span class="line"><span class="keyword">import</span> (</span><br><span class="line">    <span class="string">&quot;context&quot;</span></span><br><span class="line">    <span class="string">&quot;crypto/ecdsa&quot;</span></span><br><span class="line">    <span class="string">&quot;fmt&quot;</span></span><br><span class="line">    <span class="string">&quot;log&quot;</span></span><br><span class="line">    <span class="string">&quot;math/big&quot;</span></span><br><span class="line">    <span class="string">&quot;net/http&quot;</span></span><br><span class="line">    <span class="string">&quot;strings&quot;</span></span><br><span class="line">    <span class="string">&quot;bytes&quot;</span></span><br><span class="line">    <span class="string">&quot;io/ioutil&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="string">&quot;github.com/ethereum/go-ethereum/accounts/abi&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/ethereum/go-ethereum/accounts/abi/bind&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/ethereum/go-ethereum/common&quot;</span></span><br><span class="line">    <span class="string">&quot;github.com/ethereum/go-ethereum/crypto&quot;</span></span><br><span class="line">)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将智能合约的ABI复制到这里，需要先经过压缩转义</span></span><br><span class="line"><span class="keyword">var</span> contractABI = <span class="string">&quot;</span></span><br><span class="line"><span class="string">[&#123;\&quot;inputs\&quot;:[&#123;\&quot;internalType\&quot;:\&quot;uint256\&quot;,\&quot;name\&quot;:\&quot;x\&quot;,\&quot;type\&quot;:\&quot;uint256\&quot;&#125;],\&quot;name\&quot;:\&quot;add\&quot;,\&quot;outputs\&quot;:[],\&quot;stateMutability\&quot;:\&quot;nonpayable\&quot;,\&quot;type\&quot;:\&quot;function\&quot;&#125;,&#123;\&quot;inputs\&quot;:[],\&quot;name\&quot;:\&quot;get\&quot;,\&quot;outputs\&quot;:[&#123;\&quot;internalType\&quot;:\&quot;uint256\&quot;,\&quot;name\&quot;:\&quot;\&quot;,\&quot;type\&quot;:\&quot;uint256\&quot;&#125;],\&quot;stateMutability\&quot;:\&quot;view\&quot;,\&quot;type\&quot;:\&quot;function\&quot;&#125;,&#123;\&quot;inputs\&quot;:[&#123;\&quot;internalType\&quot;:\&quot;uint256\&quot;,\&quot;name\&quot;:\&quot;x\&quot;,\&quot;type\&quot;:\&quot;uint256\&quot;&#125;],\&quot;name\&quot;:\&quot;set\&quot;,\&quot;outputs\&quot;:[],\&quot;stateMutability\&quot;:\&quot;nonpayable\&quot;,\&quot;type\&quot;:\&quot;function\&quot;&#125;]&quot;</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">func</span> <span class="title">main</span><span class="params">()</span></span> &#123;</span><br><span class="line">    <span class="comment">// Geth 节点的 HTTP-RPC 地址</span></span><br><span class="line">    rpcURL := <span class="string">&quot;http://localhost:8545&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 创建新账户的密码</span></span><br><span class="line">    newPassword := <span class="string">&quot;your_password&quot;</span></span><br><span class="line"></span><br><span class="line">    <span class="comment">// 构造 JSON-RPC 请求体，创建新账户</span></span><br><span class="line">    payload := strings.NewReader(<span class="string">`&#123;&quot;jsonrpc&quot;:&quot;2.0&quot;,&quot;method&quot;:&quot;personal_newAccount&quot;,&quot;params&quot;:[&quot;`</span> + newPassword + <span class="string">`&quot;],&quot;id&quot;:1&#125;`</span>)</span><br><span class="line">    resp, err := http.Post(rpcURL, <span class="string">&quot;application/json&quot;</span>, payload)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> resp.Body.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析创建新账户的响应</span></span><br><span class="line">    <span class="keyword">var</span> newAccountResp <span class="keyword">struct</span> &#123;</span><br><span class="line">        Result <span class="type">string</span> <span class="string">`json:&quot;result&quot;`</span></span><br><span class="line">        Error  *<span class="keyword">struct</span> &#123;</span><br><span class="line">            Message <span class="type">string</span> <span class="string">`json:&quot;message&quot;`</span></span><br><span class="line">        &#125; <span class="string">`json:&quot;error&quot;`</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> err := json.NewDecoder(resp.Body).Decode(&amp;newAccountResp); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> newAccountResp.Error != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatalf(<span class="string">&quot;Failed to create new account: %s&quot;</span>, newAccountResp.Error.Message)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 解析新账户地址</span></span><br><span class="line">    newAccountAddress := common.HexToAddress(newAccountResp.Result)</span><br><span class="line">    fmt.Printf(<span class="string">&quot;New account address: %s\n&quot;</span>, newAccountAddress.Hex())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 连接到本地的 Geth 节点</span></span><br><span class="line">    client, err := rpc.Dial(rpcURL)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">defer</span> client.Close()</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 获取当前 gas 价格</span></span><br><span class="line">    <span class="keyword">var</span> gasPrice *big.Int</span><br><span class="line">    <span class="keyword">if</span> err := client.CallContext(context.Background(), &amp;gasPrice, <span class="string">&quot;eth_gasPrice&quot;</span>); err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 部署智能合约</span></span><br><span class="line">    auth := bind.NewKeyedTransactor(newAccountAddress.Hex())</span><br><span class="line">    auth.Value = big.NewInt(<span class="number">0</span>)           <span class="comment">// 部署时发送的以太币数量</span></span><br><span class="line">    auth.GasLimit = <span class="type">uint64</span>(<span class="number">3000000</span>)      <span class="comment">// 指定 gas 限制</span></span><br><span class="line">    auth.GasPrice = gasPrice              <span class="comment">// 使用当前 gas 价格</span></span><br><span class="line">    input := <span class="string">&quot;0x&quot;</span> + <span class="string">&quot;6080604052348015600e575f80fd5b506101e48061001c5f395ff3fe608060405234801561000f575f80fd5b506004361061003f575f3560e01c80631003e2d21461004357806360fe47b11461005f5780636d4ce63c1461007b575b5f80fd5b61005d600480360381019061005891906100fb565b610099565b005b610079600480360381019061007491906100fb565b6100b3565b005b6100836100bc565b6040516100909190610135565b60405180910390f35b5f8054826100a7919061017b565b9050805f819055505050565b805f8190555050565b5f8054905090565b5f80fd5b5f819050919050565b6100da816100c8565b81146100e4575f80fd5b50565b5f813590506100f5816100d1565b92915050565b5f602082840312156101105761010f6100c4565b5b5f61011d848285016100e7565b91505092915050565b61012f816100c8565b82525050565b5f6020820190506101485f830184610126565b92915050565b7f4e487b71000000000000000000000000000000000000000000000000000000005f52601160045260245ffd5b5f610185826100c8565b9150610190836100c8565b92508282019050808211156101a8576101a761014e565b5b9291505056fea26469706673582212209645cec1c57b3e0ea64b23d942988cdc634242f2c015ac31b32aa6ddac78ade164736f6c63430008190033&quot;</span></span><br><span class="line">    address, tx, _, err := bind.DeployContract(auth, abi.JSON(contractABI), common.FromHex(input), client)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line">    fmt.Printf(<span class="string">&quot;Contract address: %s\n&quot;</span>, address.Hex())</span><br><span class="line"></span><br><span class="line">    <span class="comment">// 等待智能合约部署完成</span></span><br><span class="line">    _, err = bind.WaitDeployed(context.Background(), client, tx)</span><br><span class="line">    <span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">        log.Fatal(err)</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// // 输出新创建的账户地址和私钥</span></span><br><span class="line">    <span class="comment">// fmt.Printf(&quot;New account address: %s\n&quot;, newAccountAddress.Hex())</span></span><br><span class="line">    <span class="comment">// fmt.Printf(&quot;Private key: %x\n&quot;, crypto.FromECDSA(privateKey))</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>

<h2><span id="调用智能合约">调用智能合约</span></h2><h3><span id="安装-abigen-工具">安装 abigen 工具</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">go get -u github.com/ethereum/go-ethereum</span><br></pre></td></tr></table></figure>

<h3><span id="生成合约绑定代码">生成合约绑定代码</span></h3><figure class="highlight bash"><table><tr><td class="code"><pre><span class="line">abigen --sol SimpleStorage.sol --pkg main --out SimpleStorage.go</span><br></pre></td></tr></table></figure>

<h3><span id="在-main-函数中添加智能合约绑定和调用智能合约">在 main 函数中添加智能合约绑定和调用智能合约</span></h3><p>NewSimpleStorage 不是一个标准函数，而是在使用 abigen 时创建的一个函数，用于创建智能合约的绑定对象</p>
<figure class="highlight go"><table><tr><td class="code"><pre><span class="line"><span class="comment">// 创建智能合约绑定</span></span><br><span class="line">contract, err := NewSimpleStorage(address, client)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 调用智能合约的 get 函数</span></span><br><span class="line">result, err := contract.Get(<span class="literal">nil</span>)</span><br><span class="line"><span class="keyword">if</span> err != <span class="literal">nil</span> &#123;</span><br><span class="line">    log.Fatal(err)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fmt.Printf(<span class="string">&quot;Result of get function: %s\n&quot;</span>, result.String())</span><br></pre></td></tr></table></figure>
]]></content>
      <categories>
        <category>科研</category>
      </categories>
  </entry>
</search>
